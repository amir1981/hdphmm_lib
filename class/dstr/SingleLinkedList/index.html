<?php $isip_window_title = "ISIP Homepage"; ?>
<?php include("/data/isip/www/templates/documentation/header/header.html"); ?>

<!--#set var="isip_page_title" value="SingleLinkedList" -->
<?php include("/data/isip/www/templates/documentation/body/index_class.html"); ?>
<?php include("/data/isip/www/templates/documentation/body/bar.html"); ?>

<a name="name">
<b>name: <a href="/perl/ifc_document.pl?file=$isip/class/dstr/SingleLinkedList/SingleLinkedList.h">SingleLinkedList&lt;class TObject&gt</a>: public <a href
= "../DstrBase/">:DstrBase;</a></b>

<br><br>

<a name="synopsis">
<b>synopsis:</b>
<br><br>

<blockquote>
<pre>
g++ [flags ...] file ...

#include &lt;SingleLinkedList.h&gt;

SingleLinkedList(ALLOCATION alloc_d = DEF_ALLOCATION) ;
boolean insert(TObject* item, boolean insert_before);
boolean insertFirst(TObject* item);
boolean removeLast();
const TObject* getNext() const;
boolean apply(boolean (TObject::*method)());
</pre>
</blockquote>

<a name="quick_start">
<b>quick start:</b>
<br><br>

<blockquote>
<pre>
// declare a character list and add two characters into it
//
SingleLinkedList&lt;Char&gt list;
Char item0(L'a');
Char item1(L'b');
list.insertFirst(&item0);
list.insert(&item1);

// get the last character
//
list.gotoLast();
Char* item2 = list.getCurr();
if (item2->ne(item1)) {
   // error
}
</pre>
</blockquote>

<a name="description"> 
<b>description:</b>
<br><br>

The SingleLinkedList class, as its name suggests, is a list template
class that supports list processing using a data structure that
contains a pointer to the next element in the list. (A doubly linked
list, by constrast, contains a pointer to the previous node as well as
the next list). For a good reference on lists, see:

<ul>
  T. Budd,
  <i>Data Structures in C++ using the Standard Template Library</i>,
  Addison Wesley, Reading, Massachusetts, USA, pp. 185-216, 1998.
</ul>

The user may select the memory management mode in which
this class operates: USER or SYSTEM.
In SYSTEM mode, the
class is responsible for managing the memory for the
objects it contains. This implies that a copy is made each time an
object is inserted to the list. In USER mode the user is
responsible for allocation and deletion of the objects that are stored
in the list. In this mode, pointers to the external
objects are stored - a copy is not made. The best mode for your
application depends on your need to trade-off speed versus the complexity of
object management.

<br><br>

<a name="dependencies">
<b>dependencies:</b>
<br><br>

<ul>
  <li> <a href="../DstrBase/"> DstrBase </a><br>
  <li> <a href="../SingleLinkedList/SingleLinkedNode.h"> SingleLinkedNode </a><br>
  <li> <a href="../../math/vector/VectorLong"> VectorLong </a><br>
  <li> <a href="../../math/scalar/String/"> String </a> <br>
  <li> <a href="../../math/scalar/Char/"> Char </a> <br>
  <li> <a href="../../math/scalar/Long/"> Long </a><br>
  <li> <a href="../../system/Console/"> Console </a> <br>
  <li> <a href="../Stack/"> Stack </a> <br>  
</ul>

<a name="constants">
<b>public constants:</b>
<br><br>

<ul>
  <li> define the class name:

       <pre><a href="/perl/ifc_document.pl?file=$isip/class/dstr/SingleLinkedList/SingleLinkedList.h&constant=CLASS_NAME">static const SysString CLASS_NAME = L"SingleLinkedList";</a></pre>                     
       
  <li> i/o related constants:

       <pre><a href="/perl/ifc_document.pl?file=$isip/class/dstr/SingleLinkedList/SingleLinkedList.h&constant=DEF_PARAM">static const SysString DEF_PARAM = L"values";</a></pre>                            
</ul>

<a name="error">
<b>error codes:</b>
<br><br>

<ul>
  <li> general SingleLinkedList class error:
       
       <pre><a href="/perl/ifc_document.pl?err=00040300">static const long ERR = 40300;</a></pre>
</ul>

<a name="protected">
<b>protected data:</b>
<br><br>

<ul>

  <li> define the NODE object

       <pre>typedef SingleLinkedNode<TObject> NODE;</pre>
       
  
  <li> pointers to the first node, last node and current node:
       
       <pre>NODE* first_d;</pre>
       <pre>NODE* last_d;  </pre>		
       <pre>NODE* curr_d;  </pre>
       
  <li> a pointer to a node the user marks:
       
       <pre>NODE* mark_d;  </pre>

  <li> the number of nodes in the list:
       
       <pre>Long length_d;</pre>
       
  <li> the flag of memory allocation mode:
       
       <pre>ALLOCATION alloc_d;</pre>
       
  <li> debugging parameters:

       <pre><a href="/perl/ifc_document.pl?file=$isip/class/dstr/SingleLinkedList/SingleLinkedList.h&static=debug_level_d">static Integral::DEBUG debug_level_d;</a></pre>

  <li> define the memory manager:

       <pre><a href="/perl/ifc_document.pl?file=$isip/class/dstr/SingleLinkedList/SingleLinkedList.h&static=mgr_d">static MemoryManager mgr_d;</a></pre>
</ul>

<a name="public">
<b>required public methods:</b>
<br><br>

<ul>  
  <li> static methods: diagnose method is moved outside the
class header file and defined in the SingleLinkedListDiagnose.h in order to
avoid issues with the preprocessing of the diagnose code
       
       <pre><a href="/perl/ifc_document.pl?file=$isip/class/dstr/SingleLinkedList/SingleLinkedList.h&method=name">static const String& name();</a></pre>
       <pre><a href="/perl/ifc_document.pl?file=$isip/class/dstr/SingleLinkedList/SingleLinkedListDiagnose.h&method=diagnose">static boolean diagnose(Integral::DEBUG debug_level);</a></pre>
       
  <li> debug methods:

       <pre><a href="/perl/ifc_document.pl?file=$isip/class/dstr/SingleLinkedList/SingleLinkedList.h&method=setDebug">static boolean setDebug(Integral::DEBUG debug_level);</a></pre>       
       <pre><a href="/perl/ifc_document.pl?file=$isip/class/dstr/SingleLinkedList/SingleLinkedList.h&method=debug">boolean debug(const unichar* message) const;</a></pre>
       
  <li> destructor/constructor(s):
       
       <pre><a href="/perl/ifc_document.pl?file=$isip/class/dstr/SingleLinkedList/SingleLinkedList.h&method=destructor">~SingleLinkedList();</a></pre>
       <pre><a href="/perl/ifc_document.pl?file=$isip/class/dstr/SingleLinkedList/SingleLinkedList.h&method=default+constructor">SingleLinkedList(ALLOCATION alloc = DEF_ALLOCATION);</a></pre>
       <pre><a href="/perl/ifc_document.pl?file=$isip/class/dstr/SingleLinkedList/SingleLinkedList.h&method=copy+constructor">SingleLinkedList(const SingleLinkedList&lt;TObject&gt;& copy_list);</a></pre>

  <li> assign methods:
       
       <pre><a href="/perl/ifc_document.pl?file=$isip/class/dstr/SingleLinkedList/SingleLinkedList.h&method=assign&instance=1">boolean assign(const SingleLinkedList&lt;TObject&gt;& copy_list);</a></pre>

  <li> operator= methods:

       <pre><a href="/perl/ifc_document.pl?file=$isip/class/dstr/SingleLinkedList/SingleLinkedList.h&method=operator%3D">SingleLinkedList&lt;TObject&gt;& operator=(const SingleLinkedList&lt;TObject&gt;& arg);</a></pre>

  <li> equality methods:
       
       <pre><a href="/perl/ifc_document.pl?file=$isip/class/dstr/SingleLinkedList/SingleLinkedList.h&method=eq&instance=1">boolean eq(const SingleLinkedList&lt;TObject&gt;& compare_list) const;</a></pre>
       
  <li> i/o methods: refer to the <a href = "./index.html#notes">notes</a>
section for an explanation of why there are two read and write methods in
this class
       
       <pre><a href="/perl/ifc_document.pl?file=$isip/class/dstr/SingleLinkedList/SingleLinkedList.h&method=sofSize">long sofSize() const;</a></pre>
       <pre><a href="/perl/ifc_document.pl?file=$isip/class/dstr/SingleLinkedList/SingleLinkedList.h&method=read&instance=0">boolean read(Sof& sof_a, long tag_a);</a></pre>
       <pre><a href="/perl/ifc_document.pl?file=$isip/class/dstr/SingleLinkedList/SingleLinkedList.h&method=write&instance=0">boolean write(Sof& sof_a, long tag_a) const;</a></pre>
       <pre><a href="/perl/ifc_document.pl?file=$isip/class/dstr/SingleLinkedList/SingleLinkedList.h&method=read&instance=1">boolean read(Sof& sof_a, long tag_a, const String& name_a);</a></pre>              
       <pre><a href="/perl/ifc_document.pl?file=$isip/class/dstr/SingleLinkedList/SingleLinkedList.h&method=write&instance=1">boolean write(Sof& sof_a, long tag_a, const String& name_a) const;</a></pre>       
       <pre><a href="/perl/ifc_document.pl?file=$isip/class/dstr/SingleLinkedList/SingleLinkedList.h&method=readData">boolean readData(Sof& sof, const String& pname = DEF_PARAM, long size = SofParser::FULL_OBJECT, boolean param_a = true, boolean nested_a = false);</a></pre>
       <pre><a href="/perl/ifc_document.pl?file=$isip/class/dstr/SingleLinkedList/SingleLinkedList.h&method=writeData">boolean writeData(Sof& sof, const String& pname = DEF_PARAM) const;</a></pre>

  <li> memory management methods:
       
       <pre><a href="/perl/ifc_document.pl?file=$isip/class/dstr/SingleLinkedList/SingleLinkedList.h&method=new">static void* operator new(size_t size);</a></pre>
       <pre><a href="/perl/ifc_document.pl?file=$isip/class/dstr/SingleLinkedList/SingleLinkedList.h&method=new\[\]">static void* operator new[](size_t size);</a></pre>
       <pre><a href="/perl/ifc_document.pl?file=$isip/class/dstr/SingleLinkedList/SingleLinkedList.h&method=delete">static void operator delete(void* ptr);</a></pre>
       <pre><a href="/perl/ifc_document.pl?file=$isip/class/dstr/SingleLinkedList/SingleLinkedList.h&method=delete\[\]">static void operator delete[](void* ptr);</a></pre>
       <pre><a href="/perl/ifc_document.pl?file=$isip/class/dstr/SingleLinkedList/SingleLinkedList.h&method=setGrowSize">static boolean setGrowSize(long grow_size);</a></pre>
       <pre><a href="/perl/ifc_document.pl?file=$isip/class/dstr/SingleLinkedList/SingleLinkedList.h&method=clear">boolean clear(Integral::CMODE cmode = Integral::DEF_CMODE);</a></pre>
</ul>

<a name="specific">
<b>class-specific public methods:</b>
<br><br>

<ul>
  <li> overloaded operators and extensions to required methods:
       
       <pre><a href="/perl/ifc_document.pl?file=$isip/class/dstr/SingleLinkedList/SingleLinkedList.h&method=operator+()&instance=0">TObject& operator() (long index);</a></pre>
       <pre><a href="/perl/ifc_document.pl?file=$isip/class/dstr/SingleLinkedList/SingleLinkedList.h&method=operator+()&instance=1">const TObject& operator() (long index) const;</a></pre>
       <pre><a href="/perl/ifc_document.pl?file=$isip/class/dstr/SingleLinkedList/SingleLinkedList.h&method=ne">boolean ne(const SingleLinkedList&lt;TObject&gt;& compare_list) const;</a></pre>
       
  <li> positioning methods:
       
       <pre><a href="/perl/ifc_document.pl?file=$isip/class/dstr/SingleLinkedList/SingleLinkedList.h&method=gotoFirst">boolean gotoFirst();</a></pre>
       <pre><a href="/perl/ifc_document.pl?file=$isip/class/dstr/SingleLinkedList/SingleLinkedList.h&method=gotoLast">boolean gotoLast();</a></pre>
       <pre><a href="/perl/ifc_document.pl?file=$isip/class/dstr/SingleLinkedList/SingleLinkedList.h&method=gotoNext">boolean gotoNext();</a></pre>
       <pre><a href="/perl/ifc_document.pl?file=$isip/class/dstr/SingleLinkedList/SingleLinkedList.h&method=gotoPrev">boolean gotoPrev();</a></pre>
       <pre><a href="/perl/ifc_document.pl?file=$isip/class/dstr/SingleLinkedList/SingleLinkedList.h&method=gotoMark">boolean gotoMark();</a></pre>
       <pre><a href="/perl/ifc_document.pl?file=$isip/class/dstr/SingleLinkedList/SingleLinkedList.h&method=gotoPosition">boolean gotoPosition(long number);</a></pre>
       <pre><a href="/perl/ifc_document.pl?file=$isip/class/dstr/SingleLinkedList/SingleLinkedList.h&method=getPosition">long getPosition() const;</a></pre>

  <li> marking methods:
       
       <pre><a href="/perl/ifc_document.pl?file=$isip/class/dstr/SingleLinkedList/SingleLinkedList.h&method=markIsSet">boolean markIsSet() const;</a></pre>
       <pre><a href="/perl/ifc_document.pl?file=$isip/class/dstr/SingleLinkedList/SingleLinkedList.h&method=isMarkedElement">boolean isMarkedElement() const;</a></pre>
       <pre><a href="/perl/ifc_document.pl?file=$isip/class/dstr/SingleLinkedList/SingleLinkedList.h&method=clearMark">boolean clearMark();</a></pre>
       <pre><a href="/perl/ifc_document.pl?file=$isip/class/dstr/SingleLinkedList/SingleLinkedList.h&method=setMark">boolean setMark();</a></pre>

  <li> access methods:
       
       <pre><a href="/perl/ifc_document.pl?file=$isip/class/dstr/SingleLinkedList/SingleLinkedList.h&method=getFirst&instance=0">TObject* getFirst();</a></pre>
       <pre><a href="/perl/ifc_document.pl?file=$isip/class/dstr/SingleLinkedList/SingleLinkedList.h&method=getFirst&instance=1">const TObject* getFirst() const;</a></pre>
       <pre><a href="/perl/ifc_document.pl?file=$isip/class/dstr/SingleLinkedList/SingleLinkedList.h&method=getLast&instance=0">TObject* getLast();</a></pre>
       <pre><a href="/perl/ifc_document.pl?file=$isip/class/dstr/SingleLinkedList/SingleLinkedList.h&method=getLast&instance=1">const TObject* getLast() const;</a></pre>
       <pre><a href="/perl/ifc_document.pl?file=$isip/class/dstr/SingleLinkedList/SingleLinkedList.h&method=getNext&instance=0">TObject* getNext();</a></pre>
       <pre><a href="/perl/ifc_document.pl?file=$isip/class/dstr/SingleLinkedList/SingleLinkedList.h&method=getNext&instance=1">const TObject* getNext() const;</a></pre>
       <pre><a href="/perl/ifc_document.pl?file=$isip/class/dstr/SingleLinkedList/SingleLinkedList.h&method=getPrev&instance=0">TObject* getPrev();</a></pre>
       <pre><a href="/perl/ifc_document.pl?file=$isip/class/dstr/SingleLinkedList/SingleLinkedList.h&method=getPrev&instance=1">const TObject* getPrev() const;</a></pre>
       <pre><a href="/perl/ifc_document.pl?file=$isip/class/dstr/SingleLinkedList/SingleLinkedList.h&method=getMark&instance=0">TObject* getMark();</a></pre>
       <pre><a href="/perl/ifc_document.pl?file=$isip/class/dstr/SingleLinkedList/SingleLinkedList.h&method=getMark&instance=1">const TObject* getMark() const;</a></pre>
       <pre><a href="/perl/ifc_document.pl?file=$isip/class/dstr/SingleLinkedList/SingleLinkedList.h&method=getCurr&instance=0">TObject* getCurr();</a></pre>
       <pre><a href="/perl/ifc_document.pl?file=$isip/class/dstr/SingleLinkedList/SingleLinkedList.h&method=getCurr&instance=1">const TObject* getCurr() const;</a></pre>

  <li> insert and remove methods:

              <pre><a href="/perl/ifc_document.pl?file=$isip/class/dstr/SingleLinkedList/SingleLinkedList.h&method=insert&instance=0">boolean insert(TObject* item, boolean insert_before);</a></pre>
              <pre><a href="/perl/ifc_document.pl?file=$isip/class/dstr/SingleLinkedList/SingleLinkedList.h&method=insert&instance=1">boolean insert(SingleLinkedList<TObject>& ilist);</a></pre>
              <pre><a href="/perl/ifc_document.pl?file=$isip/class/dstr/SingleLinkedList/SingleLinkedList.h&method=remove&instance=0">boolean remove(TObject*& item);</a></pre>
              <pre><a href="/perl/ifc_document.pl?file=$isip/class/dstr/SingleLinkedList/SingleLinkedList.h&method=remove&instance=1">boolean remove();</a></pre>
              <pre><a href="/perl/ifc_document.pl?file=$isip/class/dstr/SingleLinkedList/SingleLinkedList.h&method=insertFirst&instance=0">boolean insertFirst(TObject* item);</a></pre>
              <pre><a href="/perl/ifc_document.pl?file=$isip/class/dstr/SingleLinkedList/SingleLinkedList.h&method=insertFirst&instance=1">boolean insertFirst(SingleLinkedList<TObject>& ilist);</a></pre>
              <pre><a href="/perl/ifc_document.pl?file=$isip/class/dstr/SingleLinkedList/SingleLinkedList.h&method=removeFirst&instance=0">boolean removeFirst(TObject*& item);</a></pre>
              <pre><a href="/perl/ifc_document.pl?file=$isip/class/dstr/SingleLinkedList/SingleLinkedList.h&method=removeFirst&instance=1">boolean removeFirst();</a></pre>
              <pre><a href="/perl/ifc_document.pl?file=$isip/class/dstr/SingleLinkedList/SingleLinkedList.h&method=insertLast&instance=0">boolean insertLast(TObject* item);</a></pre>
              <pre><a href="/perl/ifc_document.pl?file=$isip/class/dstr/SingleLinkedList/SingleLinkedList.h&method=insertLast&instance=1">boolean insertLast(SingleLinkedList<TObject>& ilist);</a></pre>
              <pre><a href="/perl/ifc_document.pl?file=$isip/class/dstr/SingleLinkedList/SingleLinkedList.h&method=removeLast&instance=0">boolean removeLast(TObject*& item);</a></pre>
              <pre><a href="/perl/ifc_document.pl?file=$isip/class/dstr/SingleLinkedList/SingleLinkedList.h&method=removeLast&instance=1">boolean removeLast();</a></pre>

  <li> property methods:

       <pre><a href="/perl/ifc_document.pl?file=$isip/class/dstr/SingleLinkedList/SingleLinkedList.h&method=isEmpty">boolean isEmpty() const;</a></pre>
       <pre><a href="/perl/ifc_document.pl?file=$isip/class/dstr/SingleLinkedList/SingleLinkedList.h&method=isFirst">boolean isFirst() const;</a></pre>
       <pre><a href="/perl/ifc_document.pl?file=$isip/class/dstr/SingleLinkedList/SingleLinkedList.h&method=isLast">boolean isLast() const;</a></pre>
       <pre><a href="/perl/ifc_document.pl?file=$isip/class/dstr/SingleLinkedList/SingleLinkedList.h&method=length">long length() const;</a></pre>
       <pre><a href="/perl/ifc_document.pl?file=$isip/class/dstr/SingleLinkedList/SingleLinkedList.h&method=find">boolean find(const TObject* item);</a></pre>
       <pre><a href="/perl/ifc_document.pl?file=$isip/class/dstr/SingleLinkedList/SingleLinkedList.h&method=contains">boolean contains(TObject* value);</a></pre>
       
  <li> ordering methods:
     
       <pre><a href="/perl/ifc_document.pl?file=$isip/class/dstr/SingleLinkedList/SingleLinkedList.h&method=sort">boolean sort(Integral::ORDER sort_order = Integral::ASCENDING, SORT_ALGO = DEF_SORT_ALGO);</a></pre>
       <pre><a href="/perl/ifc_document.pl?file=$isip/class/dstr/SingleLinkedList/SingleLinkedList.h&method=reverse">boolean reverse();</a></pre>
       <pre><a href="/perl/ifc_document.pl?file=$isip/class/dstr/SingleLinkedList/SingleLinkedList.h&method=swap">boolean swap(long i, long j);</a></pre> 
        
  <li> apply methods: methods to apply an external function to each element in
       the SingleLinkedList
       
       <pre><a href="/perl/ifc_document.pl?file=$isip/class/dstr/SingleLinkedList/SingleLinkedList.h&method=apply&instance=0">boolean apply(boolean (TObject::*method)());</a></pre>
       <pre><a href="/perl/ifc_document.pl?file=$isip/class/dstr/SingleLinkedList/SingleLinkedList.h&method=apply&instance=1">boolean apply(boolean (TObject::*method)(), SingleLinkedList&lt;TObject&gt;& arg);</a></pre>

  <li> allocation mode methods:
       
       <pre><a href="/perl/ifc_document.pl?file=$isip/class/dstr/SingleLinkedList/SingleLinkedList.h&method=getAllocationMode">ALLOCATION getAllocationMode() const;</a></pre>
       <pre><a href="/perl/ifc_document.pl?file=$isip/class/dstr/SingleLinkedList/SingleLinkedList.h&method=setAllocationMode">boolean setAllocationMode(ALLOCATION alloc);</a></pre>
</ul>


<a name="private">
<b>private methods:</b>
<br><br>

<ul>
  <li> sort methods:
       
       <pre><a href="/perl/ifc_document.pl?file=$isip/class/dstr/SingleLinkedList/SingleLinkedList.h&method=randQuickSort">boolean randQuickSort(Integral::ORDER sort_order);</a></pre>
       <pre><a href="/perl/ifc_document.pl?file=$isip/class/dstr/SingleLinkedList/SingleLinkedList.h&method=insertionSort">boolean insertionSort(Integral::ORDER sort_order);</a></pre>
       
  <li> swap methods:  exchange two nodes in the list. this method assumes
       the nodes are in the list and in the proper order. this avoids
       the overhead of checking the order. this method is used inside the
       sort algorithm.
       
       <pre><a href="/perl/ifc_document.pl?file=$isip/class/dstr/SingleLinkedList/SingleLinkedList.h&method=swap&instance=1">boolean swap(NODE*& i, NODE*& j);</a></pre>

  <li> node addressing methods:

       <pre><a href="/perl/ifc_document.pl?file=$isip/class/dstr/SingleLinkedList/SingleLinkedList.h&method=getNode">NODE* getNode(long index) const;</a></pre>       

  <li> previous node access methods:  this method finds the previous node of the given node since SingleLinkedNode has no pointer to its previous node
       
       <pre><a href="/perl/ifc_document.pl?file=$isip/class/dstr/SingleLinkedList/SingleLinkedList.h&method=getPrevNode">NODE* getPrevNode(NODE* node) const;</a></pre>

</ul>
<br>

<b>friend classes:</b>
<br><br>
<ul>
  <pre><a href="SingleLinkedListDiagnose.h">friend class SingleLinkedListDiagnose;</a></pre>
</ul>

<a name="examples">
<b>examples:</b>
<br><br>

<ul>
  
  <li> This example shows the basic operation of a SingleLinkedList

       <pre>
#include &lt;SingleLinkedList.h&gt;
#include &lt;Char.h&gt;

int main() {

  // local variables
  //
  SingleLinkedList&lt;Long&gt; s;
  Long j;

  // add 10 items to the SingleLinkedList    
  //
  for (long i = 0; i&lt; 10; i++) {
    j = i * 3;
    s.insert(&j);
  }

  // see what is on the SingleLinkedList
  //
  s.debug(L"after insertion");
       
  // get the elements and print them
  //
  s.gotoFirst();     
  Long* l = s.getFirst();
  l-&gt;debug(L"item from the List");
  
  while((l= s.getNext())!=NULL) {
    s.gotoNext();
    l-&gt;debug(L"item from the List");      
  }

  // exit gracefully
  //     
  Integral::exit();
}</pre>

  <li> This example shows the basic operation of a SingleLinkedList in USER  mode. Note that memory is manually allocated before inserting it to the List and deleted later.

       <pre>
#include &lt;SingleLinkedList.h&gt;
#include &lt;Char.h&gt;

int main() {

  // local variables
  //
  SingleLinkedList&lt;Long&gt; s(USER);
  Long* j;

  // add 10 items to the SingleLinkedList    
  //
  for (long i = 0; i< 10; i++) {
    j = new Long(i * 3);
    s.insert(j);
  }

  // see what is on the SingleLinkedList
  //
  s.debug(L"after insertion");

  // get the elements and print them
  //
  s.gotoFirst();     
  Long* l = s.getFirst();
  l-&gt;debug(L"item from the List");
  delete l;
  
  while((l=s.getNext())!=NULL) {
    s.gotoNext();
    l-&gt;debug(L"item from the List");      
    delete l;
  }

  // exit gracefully
  //     
  Integral::exit();
}</pre>
       
  <li> This example shows how to check if SingleLinkedLists are equal
       <pre>
#include &lt;SingleLinkedList.h&gt;
#include &lt;Char.h&gt;

int main() {

  // prepare items for the list
  //
  Char** items = new Char*[10];
  
  // declare a SYSTEM-allocating SingleLinkedList and add items into it
  //
  SingleLinkedList&lt;Char&gt; char_list;
  
  for (long i = 0; i &lt; 10; i++) {
    items[i] = new Char((unichar)((long)'a' + i));
    
    // insert the items to the list
    //
    char_list.insert(items[i]);
    
  }
    
  // copy the SingleLinkedList
  //
  SingleLinkedList&lt;Char&gt; char_copy_list(char_list);
  
  // declare a third list that is SYSTEM-allocating, and has the same items
  //
  SingleLinkedList&lt;Char&gt;* system_char_list = new SingleLinkedList&lt;Char&gt;();
  system_char_list-&gt;assign(char_list);
  
  // see if these SingleLinkedLists are equivalent
  //
  if(!char_list.eq(char_copy_list) || !system_char_list-&gt;eq(char_list)) {

    // exit with error
    //
    Integral::exit();
  }

  // clean up the memory used
  //
  delete system_char_list;
  delete [] items; 
  
  // exit gracefully
  //
  Integral::exit();
}
       </pre>
</ul>

<a name="notes">
<b>notes:</b>
<br><br>

<ul>
  <li> There are two memory allocation modes for SingleLinkedList as indicated
       by the protected member data, alloc_d. The default allocation mode
       is SYSTEM. If alloc_d is set to SYSTEM, the list handles allocation and
       deletion of the objects. When the user puts an object into the list, a
       copy of the object is made and inserted into the list via local memory
       allocation - note that this requires a call to the copy constructor so
       the user will experience an efficiency decrease. When the object is
       removed from the list, the object is automatically  deleted. 
       
       <br><br>
       
  <li> If alloc_d is set to USER, the user is required to handle all
       memory allocation and deletion. When the user adds an object to the
       list, the object passed in is stored in the list by  pointer reference.
       when an object is removed, the user is required to accept a pointer to
       the object.
       <br><br>

  <li> Unlike other classes, we have two read and write methods in dstr
       classes. The interface is still the same as that in other
       classes. The reason behind this is that we can not use
       "CLASS_NAME" as default argument in the read and write methods
       here because the data structures build the class name on the fly.       
</ul>

<!--#include virtual="/hse/ies/templates/documentation/footer/footer.html" -->
