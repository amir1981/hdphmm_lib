<?php $isip_window_title = "ISIP Homepage"; ?>
<?php include("/data/isip/www/templates/documentation/header/header.html"); ?>

<!--#set var="isip_page_title" value="Bessel" -->
<?php include("/data/isip/www/templates/documentation/body/index_class.html"); ?>
<?php include("/data/isip/www/templates/documentation/body/bar.html"); ?>

<a name="name">
<b>
name:
<a href="/perl/ifc_document.pl?file=$isip/class/numeric/Bessel/Bessel.h">Bessel</a></b>

<br><br>

<a name="synopsis">
<b>synopsis:</b>
<br><br>

<blockquote>
<pre>
g++ [flags ...] file ... -l /isip/tools/lib/$ISIP_BINARY/lib_numeric.a

#include &lt;Bessel.h&gt;

boolean compute(float& output, float input, long order, long nterms);
</pre>
</blockquote>

<a name="quick_start">
<b>quick start:</b>
<br><br>

<blockquote>
<pre>
float output;
Bessel::compute(output, 1.0);
Bessel::compute(output, 1.0, 0, 20);
</pre>
</blockquote>

<a name="description"> 
<b>description:</b>
<br><br>

The Bessel class implements a family of Bessel functions using
an infinite series approximation. For more details about
this implementation, see:

<ul>
  S.K. Mitra,
  <i>Digital Signal Processing</i>,
  McGraw-Hill, Boston, Massuchessetts, USA, 2001, pp. 456.
</ul>

Currently, only a zeroth order Bessel function, which is the most
common order for signal processing applications, is implemented.
A zeroth order Bessel function can be approximated by the following
power series:

<ul>
  <img src="./index_eq_00.jpg">
</ul>

Normally, 20 terms in the summation provide an acceptable level
of accuracy. This limit can be specified in the compute method.

<br><br>

<a name="dependencies">
<b>dependencies:</b>
<br><br>

<ul>
  <li> <a href="../../math/vector/VectorFloat/index.html">VectorFloat</a>
  <li> <a href="../../system/MemoryManager/index.html">MemoryManager</a>
</ul>

<a name="constants">
<b>public constants:</b>
<br><br>

<ul>
  <li> define the class name:
       
       <pre><a href="/perl/ifc_document.pl?file=$isip/class/numeric/Bessel/bessel_00.cc&constant=CLASS_NAME">static const String CLASS_NAME = L"Bessel";</a></pre>

  <li> define i/o related constants:
       
       <pre><a href="/perl/ifc_document.pl?file=$isip/class/numeric/Bessel/bessel_00.cc&constant=DEF_PARAM">static const String DEF_PARAM = L"";</pre></a>
</ul>

  <li> define default values and arguments: DEF_ORDER represents the default
       Bessel function order to be used by the compute method; DEF_NTERMS
       represents how many terms are used in the approximation.
       
       <pre>static const long DEF_ORDER = 0;</pre>
       <pre>static const long DEF_NTERMS = 20;</pre>
</ul>

<a name="error">
<b>error codes:</b>
<br><br>

<ul>
  <li> error code indicating Bessel class general error:

       <pre><a href="/perl/ifc_document.pl?err=00035500">static const long ERR = (long)35500;</a></pre>
       <pre><a href="/perl/ifc_document.pl?err=00035501">static const long ERR_UNSUPA = (long)35501;</a></pre>
</ul>

<a name="protected">
<b>protected data:</b>
<br><br>

<ul>
  <li> debug level:

       <pre><a href="/perl/ifc_document.pl?file=$isip/class/numeric/Bessel/bes_00.cc&static=debug_level_d">static Integral::DEBUG debug_level_d;</a></pre>
       
  <li> a static memory manager:

       <pre><a href="/perl/ifc_document.pl?file=$isip/class/numeric/Bessel/bes_00.cc&static=mgr_d">static MemoryManager mgr_d;</pre></a>
</ul>

<a name="public">
<b>required public methods:</b>
<br><br>

<ul>
  <li>  static methods:

       <pre><a href="/perl/ifc_document.pl?file=$isip/class/numeric/Bessel/Bessel.h&method=name">static const String& name();</a></pre>
       <pre><a href="/perl/ifc_document.pl?file=$isip/class/numeric/Bessel/bes_02.cc&method=diagnose">static boolean diagnose(Integral::DEBUG debug_level);</a></pre>

  <li> debug methods:
       
       <pre><a href="/perl/ifc_document.pl?file=$isip/class/numeric/Bessel/Bessel.h&method=setDebug">boolean setDebug(Integral::DEBUG debug_level);</a></pre>
       <pre><a href="/perl/ifc_document.pl?file=$isip/class/numeric/Bessel/bes_01.cc&method=debug">boolean debug(const unichar* message) const;</a></pre>

  <li> destructor/constructor(s):
       
       <pre><a href="/perl/ifc_document.pl?file=$isip/class/numeric/Bessel/Bessel.h&method=destructor">~Bessel();</a></pre>
       <pre><a href="/perl/ifc_document.pl?file=$isip/class/numeric/Bessel/Bessel.h&method=default+constructor">Bessel();</a></pre>
       <pre><a href="/perl/ifc_document.pl?file=$isip/class/numeric/Bessel/Bessel.h&method=copy+constructor">Bessel(const Bessel& arg);</a></pre>     

  <li> assign methods:
       
       <pre><a href="/perl/ifc_document.pl?file=$isip/class/numeric/Bessel/Bessel.h&method=assign">boolean assign(const Bessel& arg)</a></pre>

  <li> operator= methods:
       
      <pre><a href="/perl/ifc_document.pl?file=$isip/class/numeric/Bessel/Bessel.h&method=operator%3D">Bessel& operator= (const Bessel& arg);</a></pre>
                     
  <li> i/o methods:
       
       <pre><a href="/perl/ifc_document.pl?file=$isip/class/numeric/Bessel/Bessel.h&method=sofSize">long sofSize() const;</a></pre>
       <pre><a href="/perl/ifc_document.pl?file=$isip/class/numeric/Bessel/Bessel.h&method=read">boolean read(Sof& sof, long tag, const String& name = CLASS_NAME);</a></pre>
       <pre><a href="/perl/ifc_document.pl?file=$isip/class/numeric/Bessel/Bessel.h&method=write">boolean write(Sof& sof, long tag, const String& name = CLASS_NAME) const;</a></pre>
       <pre><a href="/perl/ifc_document.pl?file=$isip/class/numeric/Bessel/Bessel.h&method=readData">boolean readData(Sof& sof, const String& pname = DEF_PARAM,long size = SofParser::FULL_OBJECT, boolean param = true, boolean nested = false);</a></pre>
       <pre><a href="/perl/ifc_document.pl?file=$isip/class/numeric/Bessel/Bessel.h&method=writeData">boolean writeData(Sof& sof, const String& pname = DEF_PARAM) const;</a></pre>
       
  <li> equality methods:
       
       <pre><a href="/perl/ifc_document.pl?file=$isip/class/numeric/Bessel/Bessel.h&method=eq">boolean eq(const Bessel& arg) const;</a></pre>

  <li> memory management methods:
       
       <pre><a href="/perl/ifc_document.pl?file=$isip/class/numeric/Bessel/Bessel.h&method=new">static void* operator new(size_t size);</a></pre>
       <pre><a href="/perl/ifc_document.pl?file=$isip/class/numeric/Bessel/Bessel.h&method=new[]">static void* operator new[](size_t size);</a></pre>
       <pre><a href="/perl/ifc_document.pl?file=$isip/class/numeric/Bessel/Bessel.h&method=delete">static void operator delete(void* ptr);</a></pre>
       <pre><a href="/perl/ifc_document.pl?file=$isip/class/numeric/Bessel/Bessel.h&method=delete[]">static void operator delete[](void* ptr);</a></pre>  
       <pre><a href="/perl/ifc_document.pl?file=$isip/class/numeric/Bessel/Bessel.h&method=setGrowSize">static boolean setGrowSize(long grow_size);</a></pre>  
       <pre><a href="/perl/ifc_document.pl?file=$isip/class/numeric/Bessel/Bessel.h&method=clear">boolean clear(Integral::CMODE ctype = Integral::DEF_CMODE);</a></pre>
</ul>

<a name="specific">
<b>class-specific public methods:</b>
<br><br>

<ul>
  <li> computational methods:
       
       <pre><a href="/perl/ifc_document.pl?file=$isip/class/numeric/Bessel/bes_05.cc&method=compute&instance=0">static boolean compute(float& output, float input, long order=DEF_ORDER, long nterms=DEF_NTERMS);</a></pre>
       <pre><a href="/perl/ifc_document.pl?file=$isip/class/numeric/Bessel/bes_05.cc&method=compute&instance=1">static boolean compute(VectorFloat& output, const VectorFloat& input, long order=DEF_ORDER, long nterms=DEF_NTERMS);</a></pre>
</ul>
  
<a name="private">
<b>private methods:</b>
<br><br>

<ul>
  <li> none.
</ul>

<a name="examples">
<b>examples:</b>
<br><br>

<ul>

  <li> This example shows how to compute a value using a Bessel function:

<pre>
#include &lt;Bessel.h&gt;

int main() {

  // declare variables for the input and output
  //
  float input;
  float output;

  // compute a value using the defaults
  //
  input = 1.0;
  Bessel::compute(output, input);

  // compute a value using a specific order and power series length
  //
  input = 0.5;
  Bessel::compute(output, input, 0, 27);

  // exit gracefully
  //
  Integral::exit();
}</pre>       
</ul>

<a name="notes">
<b>notes:</b>
<br><br>

<ul>
  <li> Currently, only a zeroth order function is supported.

       <br><br>

  <li> This class has no internal data, so its compute function
       can be invoked as a static function call (the class need not
       be instantiated).
</ul>

<!--#include virtual="/hse/ies/templates/documentation/footer/footer.html" -->
